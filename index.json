[{"authors":null,"categories":null,"content":"여기는 첫 글입니다.\n섹션 A 내용 A\n섹션 B flowchart TD A[Start] --\u0026gt; B{Choice} B --\u0026gt;|Yes| C[Path 1] B --\u0026gt;|No| D[Path 2] ","date":1735606800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1736919e3,"objectID":"38114d4d9d0cd1ef39d3c152fa4e9488","permalink":"https://seungyeah.github.io/posts/first-post/","publishdate":"2024-12-31T10:00:00+09:00","relpermalink":"/posts/first-post/","section":"posts","summary":"여기는 첫 글입니다.\n섹션 A 내용 A\n섹션 B flowchart TD A[Start] --\u003e B{Choice} B --\u003e|Yes| C[Path 1] B --\u003e|No| D[Path 2] ","tags":["intro","rust"],"title":"첫 글","type":"posts"},{"authors":null,"categories":null,"content":"클로저 클로저는 익명 함수로, 환경의 변수를 캡처할 수 있습니다.\nlet expensive_closure = |num| { println!(\u0026#34;calculating slowly...\u0026#34;); thread::sleep(Duration::from_secs(2)); num }; // 간단한 형태 let add_one = |x| x + 1; let five = add_one(4); 이터레이터 이터레이터는 컬렉션의 아이템들을 순회할 수 있게 해줍니다.\nlet v1 = vec![1, 2, 3]; let v1_iter = v1.iter(); for val in v1_iter { println!(\u0026#34;Got: {}\u0026#34;, val); } 이터레이터 어댑터 이터레이터를 변환하는 메소드들입니다.\nlet v1: Vec\u0026lt;i32\u0026gt; = vec![1, 2, 3]; let v2: Vec\u0026lt;_\u0026gt; = v1.iter().map(|x| x + 1).collect(); let filtered: Vec\u0026lt;_\u0026gt; = v1.iter() .filter(|\u0026amp;x| *x \u0026gt; 1) .collect(); ","date":1705017600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"4c90486d129ef20b9a2d231155805c11","permalink":"https://seungyeah.github.io/posts/rust-post-12/","publishdate":"2024-01-12T00:00:00Z","relpermalink":"/posts/rust-post-12/","section":"posts","summary":"클로저 클로저는 익명 함수로, 환경의 변수를 캡처할 수 있습니다.\nlet expensive_closure = |num| { println!(\"calculating slowly...\"); thread::sleep(Duration::from_secs(2)); num }; // 간단한 형태 let add_one = |x| x + 1; let five = add_one(4); 이터레이터 이터레이터는 컬렉션의 아이템들을 순회할 수 있게 해줍니다.\nlet v1 = vec![1, 2, 3]; let v1_iter = v1.iter(); for val in v1_iter { println!(\"Got: {}\", val); } 이터레이터 어댑터 이터레이터를 변환하는 메소드들입니다.\nlet v1: Vec\u003ci32\u003e = vec![1, 2, 3]; let v2: Vec\u003c_\u003e = v1.iter().map(|x| x + 1).collect(); let filtered: Vec\u003c_\u003e = v1.iter() .filter(|\u0026x| *x \u003e 1) .collect(); ","tags":["rust","programming","closures"],"title":"Rust 클로저와 이터레이터","type":"posts"},{"authors":null,"categories":null,"content":"벡터 (Vector) 벡터는 같은 타입의 값들을 저장하는 가변 크기 배열입니다.\nlet mut v = Vec::new(); v.push(5); v.push(6); v.push(7); // 또는 vec! 매크로 사용 let v = vec![1, 2, 3]; 문자열 (String) Rust에는 두 가지 주요 문자열 타입이 있습니다.\nlet mut s = String::new(); s.push_str(\u0026#34;hello\u0026#34;); s.push(\u0026#39; \u0026#39;); s.push(\u0026#39;w\u0026#39;); let s1 = String::from(\u0026#34;Hello, \u0026#34;); let s2 = String::from(\u0026#34;world!\u0026#34;); let s3 = s1 + \u0026amp;s2; // s1은 더 이상 사용할 수 없음 해시맵 (HashMap) 키-값 쌍을 저장하는 컬렉션입니다.\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); let team_name = String::from(\u0026#34;Blue\u0026#34;); let score = scores.get(\u0026amp;team_name); ","date":1704931200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"56476a29209676e0f0cd1a3c5be9ef25","permalink":"https://seungyeah.github.io/posts/rust-post-11/","publishdate":"2024-01-11T00:00:00Z","relpermalink":"/posts/rust-post-11/","section":"posts","summary":"벡터 (Vector) 벡터는 같은 타입의 값들을 저장하는 가변 크기 배열입니다.\nlet mut v = Vec::new(); v.push(5); v.push(6); v.push(7); // 또는 vec! 매크로 사용 let v = vec![1, 2, 3]; 문자열 (String) Rust에는 두 가지 주요 문자열 타입이 있습니다.\nlet mut s = String::new(); s.push_str(\"hello\"); s.push(' '); s.push('w'); let s1 = String::from(\"Hello, \"); let s2 = String::from(\"world!\"); let s3 = s1 + \u0026s2; // s1은 더 이상 사용할 수 없음 해시맵 (HashMap) 키-값 쌍을 저장하는 컬렉션입니다.\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\"Blue\"), 10); scores.insert(String::from(\"Yellow\"), 50); let team_name = String::from(\"Blue\"); let score = scores.get(\u0026team_name); ","tags":["rust","programming","collections"],"title":"Rust 컬렉션: 벡터, 문자열, 해시맵","type":"posts"},{"authors":null,"categories":null,"content":"라이프타임이란? 라이프타임은 참조가 유효한 스코프를 나타냅니다.\nfn main() { let r; { let x = 5; r = \u0026amp;x; // 에러! x의 라이프타임이 더 짧음 } println!(\u0026#34;r: {}\u0026#34;, r); } 함수에서의 라이프타임 fn longest\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;a str, y: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str { if x.len() \u0026gt; y.len() { x } else { y } } 구조체에서의 라이프타임 struct ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt; { part: \u0026amp;\u0026#39;a str, } impl\u0026lt;\u0026#39;a\u0026gt; ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt; { fn level(\u0026amp;self) -\u0026gt; i32 { 3 } } 라이프타임 생략 규칙 컴파일러가 자동으로 라이프타임을 추론하는 규칙들이 있습니다.\n","date":1704844800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"316f9a80e0a857fcbc632afbc619836b","permalink":"https://seungyeah.github.io/posts/rust-post-10/","publishdate":"2024-01-10T00:00:00Z","relpermalink":"/posts/rust-post-10/","section":"posts","summary":"라이프타임이란? 라이프타임은 참조가 유효한 스코프를 나타냅니다.\nfn main() { let r; { let x = 5; r = \u0026x; // 에러! x의 라이프타임이 더 짧음 } println!(\"r: {}\", r); } 함수에서의 라이프타임 fn longest\u003c'a\u003e(x: \u0026'a str, y: \u0026'a str) -\u003e \u0026'a str { if x.len() \u003e y.len() { x } else { y } } 구조체에서의 라이프타임 struct ImportantExcerpt\u003c'a\u003e { part: \u0026'a str, } impl\u003c'a\u003e ImportantExcerpt\u003c'a\u003e { fn level(\u0026self) -\u003e i32 { 3 } } 라이프타임 생략 규칙 컴파일러가 자동으로 라이프타임을 추론하는 규칙들이 있습니다.\n","tags":["rust","programming","lifetime"],"title":"Rust 라이프타임","type":"posts"},{"authors":null,"categories":null,"content":"제네릭 타입 제네릭을 사용하면 코드 중복을 줄이고 재사용성을 높일 수 있습니다.\nfn largest\u0026lt;T: PartialOrd\u0026gt;(list: \u0026amp;[T]) -\u0026gt; \u0026amp;T { let mut largest = \u0026amp;list[0]; for item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } 구조체에서의 제네릭 struct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } 트레이트 정의 트레이트는 특정 타입이 가지고 있는 기능들을 정의합니다.\npub trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String; } impl Summary for NewsArticle { fn summarize(\u0026amp;self) -\u0026gt; String { format!(\u0026#34;{}, by {} ({})\u0026#34;, self.headline, self.author, self.location) } } ","date":1704758400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"5e6918f29ebb8e1f898b1ebfead5a780","permalink":"https://seungyeah.github.io/posts/rust-post-9/","publishdate":"2024-01-09T00:00:00Z","relpermalink":"/posts/rust-post-9/","section":"posts","summary":"제네릭 타입 제네릭을 사용하면 코드 중복을 줄이고 재사용성을 높일 수 있습니다.\nfn largest\u003cT: PartialOrd\u003e(list: \u0026[T]) -\u003e \u0026T { let mut largest = \u0026list[0]; for item in list.iter() { if item \u003e largest { largest = item; } } largest } 구조체에서의 제네릭 struct Point\u003cT\u003e { x: T, y: T, } impl\u003cT\u003e Point\u003cT\u003e { fn x(\u0026self) -\u003e \u0026T { \u0026self.x } } 트레이트 정의 트레이트는 특정 타입이 가지고 있는 기능들을 정의합니다.\npub trait Summary { fn summarize(\u0026self) -\u003e String; } impl Summary for NewsArticle { fn summarize(\u0026self) -\u003e String { format!(\"{}, by {} ({})\", self.headline, self.author, self.location) } } ","tags":["rust","programming","generics"],"title":"Rust 제네릭과 트레이트","type":"posts"},{"authors":null,"categories":null,"content":"panic!과 복구 불가능한 에러 프로그램이 복구할 수 없는 상태에 도달했을 때 panic! 매크로를 사용합니다.\nfn main() { panic!(\u0026#34;crash and burn\u0026#34;); } Result를 이용한 복구 가능한 에러 대부분의 에러는 복구 가능하며, Result\u0026lt;T, E\u0026gt; 열거형을 사용합니다.\nuse std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; { panic!(\u0026#34;파일을 열 수 없습니다: {:?}\u0026#34;, error) }, }; } ? 연산자 ? 연산자를 사용하면 에러 처리를 간단하게 할 수 있습니다.\nuse std::fs::File; use std::io::Read; use std::io; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut f = File::open(\u0026#34;hello.txt\u0026#34;)?; let mut s = String::new(); f.read_to_string(\u0026amp;mut s)?; Ok(s) } ","date":1704672e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"79a81afbb0435ef488eb21b8ac1d7eb9","permalink":"https://seungyeah.github.io/posts/rust-post-8/","publishdate":"2024-01-08T00:00:00Z","relpermalink":"/posts/rust-post-8/","section":"posts","summary":"panic!과 복구 불가능한 에러 프로그램이 복구할 수 없는 상태에 도달했을 때 panic! 매크로를 사용합니다.\nfn main() { panic!(\"crash and burn\"); } Result를 이용한 복구 가능한 에러 대부분의 에러는 복구 가능하며, Result\u003cT, E\u003e 열거형을 사용합니다.\nuse std::fs::File; fn main() { let f = File::open(\"hello.txt\"); let f = match f { Ok(file) =\u003e file, Err(error) =\u003e { panic!(\"파일을 열 수 없습니다: {:?}\", error) }, }; } ? 연산자 ? 연산자를 사용하면 에러 처리를 간단하게 할 수 있습니다.\n","tags":["rust","programming","error-handling"],"title":"Rust 에러 처리","type":"posts"},{"authors":null,"categories":null,"content":"열거형 정의 열거형은 하나의 타입이 여러 가지 값 중 하나를 가질 수 있을 때 사용합니다.\nenum IpAddrKind { V4, V6, } 데이터를 가지는 열거형 enum IpAddr { V4(u8, u8, u8, u8), V6(String), } let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(\u0026#34;::1\u0026#34;)); Option 열거형 Rust에는 null이 없는 대신 Option\u0026lt;T\u0026gt; 열거형을 제공합니다.\nenum Option\u0026lt;T\u0026gt; { Some(T), None, } match를 이용한 패턴 매칭 fn value_in_cents(coin: Coin) -\u0026gt; u8 { match coin { Coin::Penny =\u0026gt; 1, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter =\u0026gt; 25, } } ","date":1704585600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"584e61f9c17daf05b6f227f670d27e27","permalink":"https://seungyeah.github.io/posts/rust-post-7/","publishdate":"2024-01-07T00:00:00Z","relpermalink":"/posts/rust-post-7/","section":"posts","summary":"열거형 정의 열거형은 하나의 타입이 여러 가지 값 중 하나를 가질 수 있을 때 사용합니다.\nenum IpAddrKind { V4, V6, } 데이터를 가지는 열거형 enum IpAddr { V4(u8, u8, u8, u8), V6(String), } let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(\"::1\")); Option 열거형 Rust에는 null이 없는 대신 Option\u003cT\u003e 열거형을 제공합니다.\nenum Option\u003cT\u003e { Some(T), None, } match를 이용한 패턴 매칭 fn value_in_cents(coin: Coin) -\u003e u8 { match coin { Coin::Penny =\u003e 1, Coin::Nickel =\u003e 5, Coin::Dime =\u003e 10, Coin::Quarter =\u003e 25, } } ","tags":["rust","programming","enum"],"title":"Rust 열거형과 패턴 매칭","type":"posts"},{"authors":null,"categories":null,"content":"구조체 정의 구조체는 관련있는 데이터를 하나로 묶는 커스텀 데이터 타입입니다.\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } 구조체 인스턴스 생성 let user1 = User { email: String::from(\u0026#34;someone@example.com\u0026#34;), username: String::from(\u0026#34;someusername123\u0026#34;), active: true, sign_in_count: 1, }; 메소드 정의 impl 블록을 사용하여 구조체에 메소드를 정의할 수 있습니다.\nimpl User { fn is_active(\u0026amp;self) -\u0026gt; bool { self.active } fn deactivate(\u0026amp;mut self) { self.active = false; } } ","date":1704499200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"fc08567aa9672d00b181a4e41bd34e43","permalink":"https://seungyeah.github.io/posts/rust-post-6/","publishdate":"2024-01-06T00:00:00Z","relpermalink":"/posts/rust-post-6/","section":"posts","summary":"구조체 정의 구조체는 관련있는 데이터를 하나로 묶는 커스텀 데이터 타입입니다.\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } 구조체 인스턴스 생성 let user1 = User { email: String::from(\"someone@example.com\"), username: String::from(\"someusername123\"), active: true, sign_in_count: 1, }; 메소드 정의 impl 블록을 사용하여 구조체에 메소드를 정의할 수 있습니다.\nimpl User { fn is_active(\u0026self) -\u003e bool { self.active } fn deactivate(\u0026mut self) { self.active = false; } } ","tags":["rust","programming","struct"],"title":"Rust 구조체와 메소드","type":"posts"},{"authors":null,"categories":null,"content":"참조란? 참조(Reference)는 값을 소유하지 않고 해당 값을 가리키는 방법입니다.\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let len = calculate_length(\u0026amp;s1); println!(\u0026#34;The length of \u0026#39;{}\u0026#39; is {}.\u0026#34;, s1, len); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { s.len() } 가변 참조 값을 변경하려면 가변 참조를 사용해야 합니다.\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 참조 규칙 어느 시점에서든 하나의 가변 참조 또는 여러 개의 불변 참조를 가질 수 있습니다. 참조는 항상 유효해야 합니다. ","date":1704412800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"2c08a042b2bcd0249feca700a39f29e3","permalink":"https://seungyeah.github.io/posts/rust-post-5/","publishdate":"2024-01-05T00:00:00Z","relpermalink":"/posts/rust-post-5/","section":"posts","summary":"참조란? 참조(Reference)는 값을 소유하지 않고 해당 값을 가리키는 방법입니다.\nfn main() { let s1 = String::from(\"hello\"); let len = calculate_length(\u0026s1); println!(\"The length of '{}' is {}.\", s1, len); } fn calculate_length(s: \u0026String) -\u003e usize { s.len() } 가변 참조 값을 변경하려면 가변 참조를 사용해야 합니다.\nfn main() { let mut s = String::from(\"hello\"); change(\u0026mut s); } fn change(some_string: \u0026mut String) { some_string.push_str(\", world\"); } 참조 규칙 어느 시점에서든 하나의 가변 참조 또는 여러 개의 불변 참조를 가질 수 있습니다. 참조는 항상 유효해야 합니다. ","tags":["rust","programming","borrowing"],"title":"Rust 참조와 차용","type":"posts"},{"authors":null,"categories":null,"content":"소유권이란? 소유권(Ownership)은 Rust의 핵심 특징으로, 메모리 안전성을 보장하면서도 가비지 컬렉터 없이 메모리를 관리할 수 있게 해줍니다.\n소유권 규칙 Rust의 각 값은 소유자(owner)를 가집니다. 한 번에 딱 하나의 소유자만 존재할 수 있습니다. 소유자가 스코프를 벗어나면, 값이 버려집니다. Move 의미론 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; // s1이 s2로 move됨 // println!(\u0026#34;{}\u0026#34;, s1); // 에러! s1은 더 이상 유효하지 않음 Clone을 이용한 복사 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); // 깊은 복사 println!(\u0026#34;{}, {}\u0026#34;, s1, s2); // 정상 작동 ","date":1704326400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"b59f891d289cac42db40254a2645d0cd","permalink":"https://seungyeah.github.io/posts/rust-post-4/","publishdate":"2024-01-04T00:00:00Z","relpermalink":"/posts/rust-post-4/","section":"posts","summary":"소유권이란? 소유권(Ownership)은 Rust의 핵심 특징으로, 메모리 안전성을 보장하면서도 가비지 컬렉터 없이 메모리를 관리할 수 있게 해줍니다.\n소유권 규칙 Rust의 각 값은 소유자(owner)를 가집니다. 한 번에 딱 하나의 소유자만 존재할 수 있습니다. 소유자가 스코프를 벗어나면, 값이 버려집니다. Move 의미론 let s1 = String::from(\"hello\"); let s2 = s1; // s1이 s2로 move됨 // println!(\"{}\", s1); // 에러! s1은 더 이상 유효하지 않음 Clone을 이용한 복사 let s1 = String::from(\"hello\"); let s2 = s1.clone(); // 깊은 복사 println!(\"{}, {}\", s1, s2); // 정상 작동 ","tags":["rust","programming","ownership"],"title":"Rust 소유권 시스템 이해하기","type":"posts"},{"authors":null,"categories":null,"content":"변수와 불변성 Rust에서 변수는 기본적으로 불변(immutable)입니다.\nlet x = 5; // x = 6; // 에러! 불변 변수는 재할당할 수 없습니다. 가변 변수 변수를 가변으로 만들려면 mut 키워드를 사용합니다.\nlet mut x = 5; x = 6; // 정상 작동 기본 타입들 Rust의 기본 스칼라 타입들을 살펴보겠습니다.\n정수 타입 i8, i16, i32, i64, i128 (부호 있는 정수) u8, u16, u32, u64, u128 (부호 없는 정수) 부동소수점 타입 f32, f64 (32비트, 64비트 부동소수점) 불린 타입 bool (true 또는 false) 문자 타입 char (4바이트 유니코드 스칼라 값) ","date":170424e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"c818735506045cda2ae48749e1f50a92","permalink":"https://seungyeah.github.io/posts/rust-post-3/","publishdate":"2024-01-03T00:00:00Z","relpermalink":"/posts/rust-post-3/","section":"posts","summary":"변수와 불변성 Rust에서 변수는 기본적으로 불변(immutable)입니다.\nlet x = 5; // x = 6; // 에러! 불변 변수는 재할당할 수 없습니다. 가변 변수 변수를 가변으로 만들려면 mut 키워드를 사용합니다.\nlet mut x = 5; x = 6; // 정상 작동 기본 타입들 Rust의 기본 스칼라 타입들을 살펴보겠습니다.\n정수 타입 i8, i16, i32, i64, i128 (부호 있는 정수) u8, u16, u32, u64, u128 (부호 없는 정수) 부동소수점 타입 f32, f64 (32비트, 64비트 부동소수점) 불린 타입 bool (true 또는 false) 문자 타입 char (4바이트 유니코드 스칼라 값) ","tags":["rust","programming","tutorial"],"title":"Rust 기본 문법 - 변수와 타입","type":"posts"},{"authors":null,"categories":null,"content":"소개 안녕하세요! Rust 완벽 가이드 시리즈의 첫 번째 글입니다. 이 글에서는 Rust 언어에 대한 기본적인 소개와 개발 환경 설정 방법에 대해 알아보겠습니다.\nRust란? Rust는 Mozilla에서 개발한 시스템 프로그래밍 언어입니다. 2010년에 처음 공개되었으며, 2015년에 1.0 버전이 릴리스되었습니다.\nRust의 특징 메모리 안전성: 컴파일 타임에 메모리 관련 버그를 방지 동시성 안전성: 데이터 레이스 없이 안전한 동시성 프로그래밍 제로 코스트 추상화: 고수준 추상화가 런타임 오버헤드 없음 C/C++ 수준의 성능: 시스템 프로그래밍에 적합한 성능 왜 Rust를 배워야 할까? 1. 메모리 안전성 fn main() { let mut v = vec![1, 2, 3]; let first = \u0026amp;v[0]; // 불변 참조 v.push(4); // 컴파일 에러! 가변 참조와 불변 참조 동시 사용 불가 println!(\u0026#34;First: {}\u0026#34;, first); } 위 코드는 컴파일되지 않습니다. Rust의 소유권 시스템이 런타임 에러를 컴파일 타임에 방지합니다.\n2. 동시성 안전성 use std::thread; fn main() { let mut data = vec![1, 2, 3]; thread::spawn(move || { data.push(4); // data의 소유권이 스레드로 이동 }); // data.push(5); // 컴파일 에러! data는 이미 이동됨 } Rust는 컴파일 타임에 데이터 레이스를 방지합니다.\n개발 환경 설정 1. Rust 설치 Windows # rustup-init.exe 다운로드 후 실행 # https://rustup.rs/ 에서 다운로드 macOS/Linux curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh source ~/.cargo/env 2. 설치 확인 rustc --version cargo --version 3. IDE 설정 VS Code VS Code 설치 Rust 확장 설치: rust-analyzer CodeLLDB 확장 설치 (디버깅용) IntelliJ IDEA IntelliJ IDEA 설치 Rust 플러그인 설치 첫 번째 Rust 프로그램 Hello, World! fn main() { println!(\u0026#34;Hello, World!\u0026#34;); } 실행 방법 # 컴파일 및 실행 rustc hello.rs ./hello # Linux/macOS hello.exe # Windows # 또는 Cargo 사용 cargo new hello cd hello cargo run Cargo 프로젝트 구조 hello/ ├── Cargo.toml ├── src/ │ └── main.rs └── target/ Rust 기본 문법 변수 선언 fn main() { let x = 5; // 불변 변수 let mut y = 10; // 가변 변수 y = 15; // 가변 변수는 값 변경 가능 // x = 10; // 컴파일 에러! 불변 변수는 값 변경 불가 } 함수 정의 fn add(a: i32, b: i32) -\u0026gt; i32 { a + b // 세미콜론 없음 = 반환값 } fn main() { let result = add(5, 3); println!(\u0026#34;5 + 3 = {}\u0026#34;, result); } 제어 흐름 fn main() { let number = 7; if number \u0026lt; 5 { println!(\u0026#34;number는 5보다 작습니다\u0026#34;); } else if number == 5 { println!(\u0026#34;number는 5입니다\u0026#34;); } else { println!(\u0026#34;number는 5보다 큽니다\u0026#34;); } // if는 표현식으로 사용 가능 let result = if number \u0026gt; 5 { \u0026#34;큼\u0026#34; } else { \u0026#34;작음\u0026#34; }; println!(\u0026#34;결과: {}\u0026#34;, result); } 다음 단계 이제 Rust의 기본적인 개념과 환경 설정에 대해 알아보았습니다. 다음 글에서는 Rust의 핵심 개념인 **소유권(Ownership)**과 **빌림(Borrowing)**에 대해 자세히 알아보겠습니다.\n연습 문제 cargo new 명령어로 새 프로젝트를 생성해보세요 간단한 계산기 프로그램을 작성해보세요 (덧셈, 뺄셈, 곱셈, 나눗셈) 사용자로부터 입력을 받아 “안녕하세요, [이름]님!“을 출력하는 프로그램을 작성해보세요 참고 자료 Rust 공식 문서 Rust by Example Rust Playground 다음 글에서 만나요! 🚀\n","date":1704153600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"1791418a6721c26f3531c1d513492b1c","permalink":"https://seungyeah.github.io/posts/third-post/","publishdate":"2024-01-02T00:00:00Z","relpermalink":"/posts/third-post/","section":"posts","summary":"소개 안녕하세요! Rust 완벽 가이드 시리즈의 첫 번째 글입니다. 이 글에서는 Rust 언어에 대한 기본적인 소개와 개발 환경 설정 방법에 대해 알아보겠습니다.\nRust란? Rust는 Mozilla에서 개발한 시스템 프로그래밍 언어입니다. 2010년에 처음 공개되었으며, 2015년에 1.0 버전이 릴리스되었습니다.\nRust의 특징 메모리 안전성: 컴파일 타임에 메모리 관련 버그를 방지 동시성 안전성: 데이터 레이스 없이 안전한 동시성 프로그래밍 제로 코스트 추상화: 고수준 추상화가 런타임 오버헤드 없음 C/C++ 수준의 성능: 시스템 프로그래밍에 적합한 성능 왜 Rust를 배워야 할까? 1. 메모리 안전성 fn main() { let mut v = vec![1, 2, 3]; let first = \u0026v[0]; // 불변 참조 v.push(4); // 컴파일 에러! 가변 참조와 불변 참조 동시 사용 불가 println!(\"First: {}\", first); } 위 코드는 컴파일되지 않습니다. Rust의 소유권 시스템이 런타임 에러를 컴파일 타임에 방지합니다.\n","tags":["rust","programming","systems","tutorial"],"title":"Rust 소개 및 환경 설정","type":"posts"},{"authors":null,"categories":null,"content":"소개 안녕하세요! Rust 완벽 가이드 시리즈의 첫 번째 글입니다. 이 글에서는 Rust 언어에 대한 기본적인 소개와 개발 환경 설정 방법에 대해 알아보겠습니다.\nRust란? Rust는 Mozilla에서 개발한 시스템 프로그래밍 언어입니다. 2010년에 처음 공개되었으며, 2015년에 1.0 버전이 릴리스되었습니다.\nRust의 특징 메모리 안전성: 컴파일 타임에 메모리 관련 버그를 방지 동시성 안전성: 데이터 레이스 없이 안전한 동시성 프로그래밍 제로 코스트 추상화: 고수준 추상화가 런타임 오버헤드 없음 C/C++ 수준의 성능: 시스템 프로그래밍에 적합한 성능 왜 Rust를 배워야 할까? 1. 메모리 안전성 fn main() { let mut v = vec![1, 2, 3]; let first = \u0026amp;v[0]; // 불변 참조 v.push(4); // 컴파일 에러! 가변 참조와 불변 참조 동시 사용 불가 println!(\u0026#34;First: {}\u0026#34;, first); } 위 코드는 컴파일되지 않습니다. Rust의 소유권 시스템이 런타임 에러를 컴파일 타임에 방지합니다.\n2. 동시성 안전성 use std::thread; fn main() { let mut data = vec![1, 2, 3]; thread::spawn(move || { data.push(4); // data의 소유권이 스레드로 이동 }); // data.push(5); // 컴파일 에러! data는 이미 이동됨 } Rust는 컴파일 타임에 데이터 레이스를 방지합니다.\n개발 환경 설정 1. Rust 설치 Windows # rustup-init.exe 다운로드 후 실행 # https://rustup.rs/ 에서 다운로드 macOS/Linux curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh source ~/.cargo/env 2. 설치 확인 rustc --version cargo --version 3. IDE 설정 VS Code VS Code 설치 Rust 확장 설치: rust-analyzer CodeLLDB 확장 설치 (디버깅용) IntelliJ IDEA IntelliJ IDEA 설치 Rust 플러그인 설치 첫 번째 Rust 프로그램 Hello, World! fn main() { println!(\u0026#34;Hello, World!\u0026#34;); } 실행 방법 # 컴파일 및 실행 rustc hello.rs ./hello # Linux/macOS hello.exe # Windows # 또는 Cargo 사용 cargo new hello cd hello cargo run Cargo 프로젝트 구조 hello/ ├── Cargo.toml ├── src/ │ └── main.rs └── target/ Rust 기본 문법 변수 선언 fn main() { let x = 5; // 불변 변수 let mut y = 10; // 가변 변수 y = 15; // 가변 변수는 값 변경 가능 // x = 10; // 컴파일 에러! 불변 변수는 값 변경 불가 } 함수 정의 fn add(a: i32, b: i32) -\u0026gt; i32 { a + b // 세미콜론 없음 = 반환값 } fn main() { let result = add(5, 3); println!(\u0026#34;5 + 3 = {}\u0026#34;, result); } 제어 흐름 fn main() { let number = 7; if number \u0026lt; 5 { println!(\u0026#34;number는 5보다 작습니다\u0026#34;); } else if number == 5 { println!(\u0026#34;number는 5입니다\u0026#34;); } else { println!(\u0026#34;number는 5보다 큽니다\u0026#34;); } // if는 표현식으로 사용 가능 let result = if number \u0026gt; 5 { \u0026#34;큼\u0026#34; } else { \u0026#34;작음\u0026#34; }; println!(\u0026#34;결과: {}\u0026#34;, result); } 다음 단계 이제 Rust의 기본적인 개념과 환경 설정에 대해 알아보았습니다. 다음 글에서는 Rust의 핵심 개념인 **소유권(Ownership)**과 **빌림(Borrowing)**에 대해 자세히 알아보겠습니다.\n연습 문제 cargo new 명령어로 새 프로젝트를 생성해보세요 간단한 계산기 프로그램을 작성해보세요 (덧셈, 뺄셈, 곱셈, 나눗셈) 사용자로부터 입력을 받아 “안녕하세요, [이름]님!“을 출력하는 프로그램을 작성해보세요 참고 자료 Rust 공식 문서 Rust by Example Rust Playground 다음 글에서 만나요! 🚀\n","date":1704153600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"b0489e317d51f66717a96aeb46bbc387","permalink":"https://seungyeah.github.io/posts/third-post2/","publishdate":"2024-01-02T00:00:00Z","relpermalink":"/posts/third-post2/","section":"posts","summary":"소개 안녕하세요! Rust 완벽 가이드 시리즈의 첫 번째 글입니다. 이 글에서는 Rust 언어에 대한 기본적인 소개와 개발 환경 설정 방법에 대해 알아보겠습니다.\nRust란? Rust는 Mozilla에서 개발한 시스템 프로그래밍 언어입니다. 2010년에 처음 공개되었으며, 2015년에 1.0 버전이 릴리스되었습니다.\nRust의 특징 메모리 안전성: 컴파일 타임에 메모리 관련 버그를 방지 동시성 안전성: 데이터 레이스 없이 안전한 동시성 프로그래밍 제로 코스트 추상화: 고수준 추상화가 런타임 오버헤드 없음 C/C++ 수준의 성능: 시스템 프로그래밍에 적합한 성능 왜 Rust를 배워야 할까? 1. 메모리 안전성 fn main() { let mut v = vec![1, 2, 3]; let first = \u0026v[0]; // 불변 참조 v.push(4); // 컴파일 에러! 가변 참조와 불변 참조 동시 사용 불가 println!(\"First: {}\", first); } 위 코드는 컴파일되지 않습니다. Rust의 소유권 시스템이 런타임 에러를 컴파일 타임에 방지합니다.\n","tags":["rust","programming","systems","tutorial"],"title":"Rust 소개 및 환경 설정2","type":"posts"},{"authors":null,"categories":null,"content":"소개 안녕하세요! 이 글에서는 Hugo를 사용하여 정적 블로그를 구축하는 방법에 대해 알아보겠습니다.\nHugo란? Hugo는 Go 언어로 작성된 정적 사이트 생성기입니다. 빠른 속도와 간단한 사용법으로 많은 개발자들이 선호하는 도구입니다.\n주요 특징 빠른 속도: Go 언어의 성능을 활용하여 매우 빠른 빌드 속도 간단한 사용법: 단일 바이너리로 실행 가능 다양한 테마: 수많은 오픈소스 테마 제공 마크다운 지원: 간편한 콘텐츠 작성 설치 방법 1. Hugo 설치 # macOS brew install hugo # Windows choco install hugo-extended # Linux sudo apt install hugo 2. 새 사이트 생성 hugo new site my-blog cd my-blog 3. 테마 추가 git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; config.toml 첫 번째 포스트 작성 hugo new posts/my-first-post.md 마크다운 파일을 편집하여 콘텐츠를 작성합니다:\n--- title: \u0026#34;My First Post\u0026#34; date: 2024-01-01 --- 안녕하세요! 이것은 제 첫 번째 포스트입니다. 로컬 서버 실행 hugo server -D 브라우저에서 http://localhost:1313으로 접속하여 결과를 확인할 수 있습니다.\n배포 GitHub Pages # 빌드 hugo --minify # public 폴더를 GitHub Pages에 배포 Netlify Netlify는 자동 배포를 지원합니다. GitHub 저장소와 연결하면 자동으로 빌드하고 배포합니다.\n결론 Hugo는 정적 블로그를 구축하기에 매우 좋은 도구입니다. 빠른 속도와 간단한 사용법으로 개발자 블로그 구축에 적합합니다.\n앞으로 더 많은 기능과 팁을 공유하겠습니다. 감사합니다!\n","date":1704067200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"dc94e0c51c4569b62092c64a51bb00c3","permalink":"https://seungyeah.github.io/posts/second-post/","publishdate":"2024-01-01T00:00:00Z","relpermalink":"/posts/second-post/","section":"posts","summary":"소개 안녕하세요! 이 글에서는 Hugo를 사용하여 정적 블로그를 구축하는 방법에 대해 알아보겠습니다.\nHugo란? Hugo는 Go 언어로 작성된 정적 사이트 생성기입니다. 빠른 속도와 간단한 사용법으로 많은 개발자들이 선호하는 도구입니다.\n주요 특징 빠른 속도: Go 언어의 성능을 활용하여 매우 빠른 빌드 속도 간단한 사용법: 단일 바이너리로 실행 가능 다양한 테마: 수많은 오픈소스 테마 제공 마크다운 지원: 간편한 콘텐츠 작성 설치 방법 1. Hugo 설치 # macOS brew install hugo # Windows choco install hugo-extended # Linux sudo apt install hugo 2. 새 사이트 생성 hugo new site my-blog cd my-blog 3. 테마 추가 git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \"theme = 'ananke'\" \u003e\u003e config.toml 첫 번째 포스트 작성 hugo new posts/my-first-post.md 마크다운 파일을 편집하여 콘텐츠를 작성합니다:\n","tags":["hugo","blog","getting-started"],"title":"Hello World - Hugo 블로그 시작하기","type":"posts"},{"authors":null,"categories":null,"content":"Rust 언어의 기초부터 고급 주제까지 다루는 시리즈입니다.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"4ad4fce78cfa9ceede55e13545f21464","permalink":"https://seungyeah.github.io/series/rust-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/series/rust-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","section":"series","summary":"Rust 언어의 기초부터 고급 주제까지 다루는 시리즈입니다.\n","tags":["rust","programming","systems"],"title":"Rust 프로그래밍","type":"series"},{"authors":null,"categories":null,"content":"Hugo와 GitHub Style 테마를 사용한 블로그 구축 방법을 다루는 시리즈입니다.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1755458108,"objectID":"8868b2d41d243bd478444efec5c65aa6","permalink":"https://seungyeah.github.io/series/%EC%83%98%ED%94%8C-%EC%8B%9C%EB%A6%AC%EC%A6%88/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/series/%EC%83%98%ED%94%8C-%EC%8B%9C%EB%A6%AC%EC%A6%88/","section":"series","summary":"Hugo와 GitHub Style 테마를 사용한 블로그 구축 방법을 다루는 시리즈입니다.\n","tags":["hugo","blog","tutorial"],"title":"샘플 시리즈","type":"series"}]